const express = require('express');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const { getSubtitles } = require('youtube-caption-extractor');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

const app = express();
const port = process.env.PORT || 3000;

app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());

// In-memory storage for progress (replace with a database in production)
const progressStore = {};

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

function extractVideoId(url) {
    const match = url.match(/(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([^"&?\/\s]{11})/);
    return match ? match[1] : null;
}

function secondsToSrtTimecode(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    const ms = Math.floor((seconds - Math.floor(seconds)) * 1000);
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')},${String(ms).padStart(3, '0')}`;
}

async function translateText(text, targetLang, apiKey, modelName, retry = true) {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: modelName });
    const prompt = `Translate the following subtitle text into ${targetLang} while maintaining:
- Natural, conversational tone
- Proper grammar and sentence structure
- Contextual accuracy
- Consistent terminology
- Appropriate length for on-screen display

Avoid:
- Literal translations
- Overly formal or bookish language
- Unnatural phrasing
- Excessive wordiness

Return ONLY the translated phrase separated by a newline, and nothing else. Do not include any introductory text. Do not include any numbering. Do not skip any lines.

Input Text:
${text}`;

    try {
        console.log(`[TRANSLATE] Translating: ${text}`);
        const result = await model.generateContent(prompt);
        return result.response.text().trim();
    } catch (error) {
        if (error.status === 429 && retry) {
            console.log('[TRANSLATE] Gemini 429 error, waiting 60 seconds before retry...');
            await delay(60000);
            return translateText(text, targetLang, apiKey, modelName, false);
        }
        throw error;
    }
}

// Custom function to get available subtitle languages
async function getAvailableLanguages(videoID) {
    try {
        // Use dynamic import() to load node-fetch
        const { default: fetch } = await import('node-fetch'); // Corrected import

        const response = await fetch(`https://youtube.com/watch?v=${videoID}`);
        const data = await response.text();

        if (!data.includes('captionTracks')) {
            console.warn(`[LANG] No captions found for video: ${videoID}`);
            return [];
        }

        const regex = /"captionTracks":(\[.*?\])/;
        const regexResult = regex.exec(data);

        if (!regexResult) {
            console.warn(`[LANG] Failed to extract captionTracks from video: ${videoID}`);
            return [];
        }

        const [_, captionTracksJson] = regexResult;
        const captionTracks = JSON.parse(captionTracksJson);

        return captionTracks.map(track => ({
            code: track.languageCode || track.vssId.replace(/^[.a]\./, ''),
            name: track.name?.simpleText || track.languageCode || track.vssId.replace(/^[.a]\./, ''),
            isAutoGenerated: track.vssId.startsWith('a.')
        }));
    } catch (error) {
        console.error(`[LANG] Error fetching available languages: ${error.message}`);
        return [];
    }
}

// --- API Endpoints ---

app.post('/get-video-details', async (req, res) => {
    const { url } = req.body;

    if (!url) { return res.status(400).json({ error: 'YouTube URL is required' }); }
    const videoId = extractVideoId(url);
    if (!videoId) { return res.status(400).json({ error: 'Invalid YouTube URL' }); }

    try {
        console.log(`[DETAILS] Fetching video details for Video ID: ${videoId}`);
        const availableLanguages = await getAvailableLanguages(videoId);
        res.json({ availableLanguages });
    } catch (error) {
        console.error(`[DETAILS] Error: ${error.message}`);
        res.status(500).json({ error: error.message });
    }
});

app.post('/fetch-subtitles', async (req, res) => {
    const { url, languageCode } = req.body;

    if (!url) { return res.status(400).json({ error: 'YouTube URL is required' }); }
    if (!languageCode) { return res.status(400).json({ error: 'Language code is required' }); }
    const videoId = extractVideoId(url);
    if (!videoId) { return res.status(400).json({ error: 'Invalid YouTube URL' }); }

    try {
        console.log(`[FETCH] Fetching subtitles. Video ID: ${videoId}, Language: ${languageCode}`);
        const subtitles = await getSubtitles({ videoID: videoId, lang: languageCode });
        if (!subtitles || subtitles.length === 0) {
            throw new Error(`No subtitles found for language: ${languageCode}`);
        }

        const srt = subtitles.map((item, index) =>
            `${index + 1}\n${secondsToSrtTimecode(parseFloat(item.start))} --> ${secondsToSrtTimecode(parseFloat(item.start) + parseFloat(item.dur))}\n${item.text.trim()}\n`
        ).join('\n');
        res.json({ srt });
    } catch (error) {
        console.error(`[FETCH] Error: ${error.message}`);
        res.status(404).json({ error: error.message });
    }
});

app.get('/progress/:id', (req, res) => {
    const { id } = req.params;
    const progress = progressStore[id];

    if (progress) {
        res.json(progress);
    } else {
        res.status(404).json({ error: 'Translation not found' });
    }
});

app.post('/process-subtitles', async (req, res) => {
    const { apiKey, srt, lang, downloadOnly, linesPerRequest, model } = req.body;

    if (!apiKey) { return res.status(400).json({ error: 'Gemini API key is required' }); }
    if (!srt) { return res.status(400).json({ error: 'Subtitles content is required' }); }
    if (!downloadOnly && !lang) { return res.status(400).json({ error: 'Target language is required' }); }
    if (!downloadOnly && !linesPerRequest) { return res.status(400).json({ error: 'Lines per request is required' }); }

    const translationId = uuidv4();
    progressStore[translationId] = {
        message: 'Starting...',
        progress: 0,
        total: 0,
        completed: false,
        srt: null,
    };

    res.json({ translationId });

    (async () => {
        try {
            let finalSrt = srt;

            if (!downloadOnly) {
                const lines = finalSrt.split('\n');
                const transcript = [];
                let currentItem = null;

                for (const line of lines) {
                    if (line.includes('-->')) {
                        currentItem = { time: line, text: '' };
                    } else if (line.trim() && currentItem && !/^\d+$/.test(line)) {
                        currentItem.text += line.trim() + ' ';
                    } else if (!line.trim() && currentItem) {
                        transcript.push(currentItem);
                        currentItem = null;
                    }
                }

                const total = transcript.length;
                progressStore[translationId].total = total;
                const translations = [];
                const maxLines = Math.min(parseInt(linesPerRequest, 10) || 1, 50);

                for (let i = 0; i < total; i += maxLines) {
                    const batch = transcript.slice(i, i + maxLines);
                    const batchText = batch.map(item => item.text.trim()).join('\n');

                    progressStore[translationId] = {
                        ...progressStore[translationId],
                        message: `Translating lines ${i + 1} to ${Math.min(i + maxLines, total)} of ${total}`,
                        progress: Math.min(i + maxLines, total),
                    };

                    const translatedBatch = await translateText(batchText, lang, apiKey, model);
                    translations.push(...translatedBatch.split('\n'));

                    if (i + maxLines < total) {
                        await delay(4000);
                    }
                }

                finalSrt = transcript.map((item, index) =>
                    `${index + 1}\n${item.time}\n${translations[index] || item.text.trim()}\n`
                ).join('\n');
            }

            progressStore[translationId] = {
                ...progressStore[translationId],
                message: 'Translation Complete!',
                progress: progressStore[translationId].total,
                completed: true,
                srt: finalSrt,
            };
        } catch (error) {
            console.error('Error in processing:', error);
            progressStore[translationId] = {
                ...progressStore[translationId],
                message: 'Error during translation',
                error: error.message,
                completed: true,
            };
        }
    })();
});

(async () => {
    try {
        console.log('[INIT] Starting server');
        app.listen(port, () => {
            console.log(`[INIT] Server running at http://localhost:${port}`);
        });
    } catch (error) {
        console.error('[INIT] Startup error:', error);
        process.exit(1);
    }
})();